- [[编译原理]]
- ### 广度优先搜索（BFS）
- BFS就像是在迷宫里，每次都先探索离你最近的那些路。它先看看所有可能的下一步，然后再一个个尝试。这种方法的好处是，它肯定能找到解决方案，如果有的话。就像是，你不会错过任何一个可能的转角。但问题是，如果这个迷宫特别大，你可能就要走很多无用的路，因为你得把所有近的路都走一遍。所以，BFS可能会占用很多内存，特别是在状态空间很大的时候。
- ### 深度优先搜索（DFS）
- DFS的思路完全不一样，它就像是选了一个方向，然后一直往那个方向走，直到走不通了再回头。这种方法的好处是它不会像BFS那样占用太多内存，因为它一次只探索一条路径。但坏处是，你可能走了很多无用的路，特别是如果你一开始就选错了方向。而且，DFS不一定能找到最短的解决方案，有时候甚至可能找不到解决方案，尤其是在有循环的情况下。
- ### A*搜索
- A*搜索则更灵活一些。它结合了BFS和DFS的优点。A*用一个叫做启发式的函数来估计每一步到目标的距离。这就像是，你有个大致的地图，知道每个转角离终点有多远。这样你就可以优先走那些看起来更接近目标的路。A*搜索的妙处在于，如果你的启发式函数设计得好，它既能找到最短的解决方案，又不会像BFS那样占用太多内存。
- 每种方法都有它的好处和不足。选择哪种方法，就像是解决问题的策略，要看你面对的是什么样的“迷宫”。有的时候你需要快速浏览所有可能的路径（BFS），有的时候你可能需要深入探索（DFS），有时候需要灵活一点，优先走那些看起来更有希望的路（A*）。
-
- ### 时间和空间复杂度分析
- **深度优先搜索 (DFS)**
- 时间复杂度：O(b^m)，其中b是分支因子，m是最大深度。
	- 空间复杂度：O(bm)，主要是由于需要存储栈。
- **一致代价搜索**
- 时间复杂度：O(b^c)，其中c是目标成本。
	- 空间复杂度：O(b^c)，因为它需要存储所有扩展的节点。
- **迭代加深的深度优先搜索 (IDDFS)**
- 时间复杂度：O(b^d)，其中d是目标的深度。
	- 空间复杂度：O(bd)，因为它在每个深度限制下只存储单路径。
- **A*搜索**
- 时间复杂度：依赖于启发式函数，理想情况下是O(b^d)，但可能更差。
	- 空间复杂度：O(b^d)，因为需要存储所有扩展的节点。
-
-