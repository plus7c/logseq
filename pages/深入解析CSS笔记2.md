- 《深入解析CSS》
  基思·J.格兰特
  111个笔记
- ◆ 1.1 层叠
- >>  如果选择器的ID数量更多，则它会胜出（即它更明确）。❑ 如果ID数量一致，那么拥有最多类的选择器胜出。❑ 如果以上两次比较都一致，那么拥有最多标签名的选择器胜出。
- >> 伪类选择器（如：hover）和属性选择器（如[type="input"]）与一个类选择器的优先级相同。通用选择器（＊）和组合器（>、+、~）对优先级没有影响。
- >> 通过这些例子可以发现，优先级容易发展为一种“军备竞赛”。在大型项目中这一点尤为突出。通常最好让优先级尽可能低，这样当需要覆盖一些样式时，才能有选择空间。
- ◆ 2.2 em和rem
- >> 在CSS里，答案通常是“看情况”。rem只是你工具包中的一种工具。掌握CSS很重要的一点是学会在适当的场景使用适当的工具。我一般会用rem设置字号，用px设置边框，用em设置其他大部分属性，尤其是内边距、外边距和圆角（不过我有时用百分比设置容器宽度）
- >> 拿不准的时候，用rem设置字号，用px设置边框，用em设置其他大部分属性。
- ◆ 2.3 停止像素思维
- >> 通过给页面根元素设置不同字号，我们响应式地重新定义了整个网页的em和rem。也就是说，即使不直接修改面板的样式，它也是响应式的。在小屏上，比如智能手机上，字体会较小（12px），内边距和圆角也相应较小。在大于800px和1200px的大屏上，组件会相应地分别放大到14px和16px的字号。缩放浏览器窗口可以看到这些变化。如果你足够严格，整个网页的样式都像这样使用相对单位定义，那么网页就会根据视口大小整体缩放。这是响应式策略中很重要的一部分。靠近样式表顶部的两个媒体查询可以极大减少后续CSS代码中媒体查询的数量。如果用像素的话，就没有这么容易。同样，如果老板或者客户觉得网页的字体太大或者太小，只需要改一行代码就能改变整体的字号，进而不费吹灰之力影响整个网页。
- ◆ 2.4 视口的相对单位
- >> 现在打开网页，慢慢缩放浏览器，字体会平滑地缩放。0.5em保证了最小字号，1vw则确保了字体会随着视口缩放。这段代码保证基础字号从iPhone 6里的11.75px一直过渡到1200px的浏览器窗口里的20px。可以按照自己的喜好调整这个值。
- ◆ 2.6 自定义属性（即CSS变量）
- >> 调用函数var()就能使用该变量。
- >> 在不支持自定义属性的浏览器上，任何使用var()的声明都会被忽略。请尽量为这些浏览器提供回退方案。
- ◆ 2.7 总结
- >> 拥抱相对单位，让网页的结构决定样式的含义。
- >> 建议用rem设置字号，但是有选择地用em实现网页组件的简单缩放。
- >> 不用媒体查询也能让整个网页响应式缩放。
- >> 使用无单位的值设置行高。
- >> 请开始熟悉CSS的一个新特性：自定义属性。
- ◆ 3.1 元素宽度的问题
- >> 26%是一个魔术数值（magic number）。它不是一个理想的值，而是通过改样式试出来的值。
- >> box-sizing的默认值为content-box，这意味任何指定的宽或高都只会设置内容盒子的大小。将box-sizing设置为border-box后，height和width属性会设置内容、内边距以及边框的大小总和，这刚好符合示例的要求。
- >> 如果要开发一个新的网站，我建议将代码清单3-6加到CSS中，因为从长远来看，这会给你省去很多麻烦。
- >> 这种方式不仅能够使用em指定间距，而且能让代码意图更明显。之后再看代码，从代码清单3-7中可能看不出为什么使用29%，但是代码清单3-8中的30% -1.5em则能提供线索，知道它是基于30%算出来的。
- ◆ 3.2 元素高度的问题
- >> 通常情况下，我倾向于使用auto而不是scroll，因为在大多数情况下，我不希望滚动条一直出现
- >> 如果将主列和侧边栏的高度对齐（如图3-10所示），看起来就会更精致。任意一列的内容增加，两列的高度都会增加，同时保持底部对齐。
- >> 正的外边距会将容器的边缘往里推，而负的外边距则会将边缘往外拉
- >> Flexbox不需要一个额外的div包裹元素，它默认会产生等高的元素。此外也不需要使用负外边距。
- >> 给容器设置display: flex，它就变成了一个弹性容器（flex container），子元素默认等高。
- >> 除非别无选择，否则不要明确设置元素的高度。先寻找一个替代方案。设置高度一定会导致更复杂的情况。
- >> vertical-align声明只会影响行内元素或者table-cell元素。对于行内元素，它控制着该元素跟同一行内其他元素之间的对齐关系。
- ◆ 3.4 外边距折叠
- >> 折叠外边距的大小等于相邻外边距中的最大值。
- >> 只有上下外边距会产生折叠，左右外边距不会折叠
- >> 折叠外边距就像“个人空间”。如果在公交车站站着两个人，他们每个人都认为较为舒适的个人空间应为3英尺[插图]，那么他们就会乐意间隔3英尺，而不必间隔6英尺才让双方满意。
- >> 这也就是说可以给任何元素加上外边距，而不必担心它们前后的元素是什么。
- ◆ 3.6 总结
- >> ❑ 总是全局设置border-box，以便得到预期的元素大小。❑ 避免明确设置元素的高度，以免出现溢出问题。❑ 使用现代的布局技术，比如display: table或者Flexbox实现列等高或者垂直居中内容。❑ 如果外边距的行为很奇怪，就采取措施防止外边距折叠。❑ 使用猫头鹰选择器全局设置堆叠元素之间的外边距。
- ◆ 4.1 浮动的设计初衷
- >> 这里使用了max-width而不是width，因此如果视口宽度小于1080px的话，内层容器就能缩小到1080px以下。换句话说，在小视口上，内层容器会填满屏幕，在大视口上，它会扩展到1080px。这种方式能有效避免在小屏幕上出现水平滚动条。
- ◆ 4.2 容器折叠和清除浮动
- >> 要用display: table来清除浮动，同时利用隐式创建单元格来包含外边距
- ◆ 4.4 媒体对象和BFC
- >> 为了实现右边这种布局，需要为正文建立一个块级格式化上下文（block formatting context,BFC）。BFC是网页的一块区域，元素基于这块区域布局。虽然BFC本身是环绕文档流的一部分，但它将内部的内容与外部的上下文隔离开。
- >> 简而言之，BFC里的内容不会跟外部的元素重叠或者相互影响。如果给元素增加clear属性，它只会清除自身所在BFC内的浮动。如果强制给一个元素生成一个新的BFC，它不会跟其他BFC重叠。
- >> 给元素添加以下的任意属性值都会创建BFC。❑ float: left或right，不为none即可。❑ overflow:hidden、auto或scroll，不为visible即可。❑ display:inline-block、table-cell、table-caption、flex、inline-flex、grid或inline-grid。拥有这些属性的元素称为块级容器（block container）。❑ position:absolute或position: fixed。
- >> 使用overflow: auto通常是创建BFC最简单的一种方式
- ◆ 4.5 网格系统
- >> ＊=比较符可以匹配任意包含指定字符串的值，比如本例中可以匹配在类属性的任意位置出现column-的元素。
- ◆ 4.6 总结
- >> 浮动的设计初衷是让文字围绕一个元素排列，但有时这种效果并不是我们想要的。❑ 使用清除浮动来包含浮动元素。❑ BFC有3个好处：包含浮动元素，防止外边距折叠，防止文档流围绕浮动元素排列。❑ 使用双容器模式让页面内容居中。❑ 使用媒体对象模式将描述文字定位到图片旁边。❑ 使用网格系统实现更丰富的网页布局。
- ◆ 5.2 弹性子元素的大小
- >> flex-basis定义了元素大小的基准值，即一个初始的“主尺寸”。
- >> 多出来的留白（或剩余宽度）会按照flex-grow（增长因子）的值分配给每个弹性子元素，flex-grow的值为非负整数。
- >> flex-shrink属性与flex-grow遵循相似的原则。计算出弹性子元素的初始主尺寸后，它们的累加值可能会超出弹性容器的可用宽度。如果不用flex-shrink，就会导致溢出（如图5-12所示
- >> 每个子元素的flex-shrink值代表了它是否应该收缩以防止溢出。如果某个子元素为flex-shrink: 0，则不会收缩；如果值大于0，则会收缩至不再溢出。按照flex-shrink值的比例，值越大的元素收缩得越多。
- ◆ 5.4 对齐、间距等细节
- >> 值space-between将第一个弹性子元素放在主轴开始的地方，最后一个子元素放在主轴结束的地方，剩下的子元素间隔均匀地放在这两者之间的区域。值space-around类似，只不过给第一个子元素的前面和最后一个子元素的后面也加上了相同的间距。间距是在元素的外边距之后进行计算的，而且flex-grow的值要考虑进来。也就是说，如果任意子元素的flex-grow的值不为0，或者任意子元素在主轴方向的外边距值为auto, justify-content就失效了。
- >> justify-content控制子元素在主轴方向的对齐方式，align-items则控制子元素在副轴方向的对齐方式。
- >> 两个弹性子元素的属性：align-self和order。
- >> 该属性控制弹性子元素沿着容器副轴方向的对齐方式。它跟弹性容器的align-items属性效果相同，但是它能单独给弹性子元素设定不同的对齐方式
- ◆ 5.5 值得注意的地方
- >> Flexbox的实现是CSS的一大进步。一旦你熟悉了它，你可能想要在页面的每个地方都开始使用，不过你应该依靠正常的文档流，只在必要的时候才使用Flexbox。这么说并不是让你不用它，而是希望你不要拿着锤子满世界找钉子。
- >> 他给出的一个建议是对整页布局的时候使用网格布局
- ◆ 5.6 总结
- >> 使用align-items和align-self让一个弹性子元素在弹性容器中垂直居中。
- ◆ 6.2 网格剖析
- >> 有一点值得注意的是，使用网格并不会让Flexbox失去用武之地。在这个网页的布局里面Flexbox仍然是重要部分。我会把应当使用Flexbox的地方指出来。
- >> 用repeat()符号还可以定义不同的重复模式，比如repeat(3, 2fr 1fr)会重复三遍这个模式，从而定义六个网格轨道，重复的结果是2fr 1fr 2fr 1fr 2fr 1fr。
- >> 学了网格之后，开发人员经常会问到Flexbox，特别是会问这两种布局方式是否互斥。当然不会，它们是互补的。二者几乎是一起开发出来的，虽然它们的功能有一些重叠的地方，但是它们各自擅长的场景不一样。在一个设计场景里，要根据特定的需求来做出选择。
- >>  Flexbox本质上是一维的，而网格是二维的
- >> Flexbox是以内容为切入点由内向外工作的，而网格是以布局为切入点从外向内工作的
- >> 因为Flexbox是一维的，所以它很适合用在相似的元素组成的行（或列）上。它支持用flex-wrap换行，但是没法让上一行元素跟下一行元素对齐。相反，网格是二维的，旨在解决一个轨道的元素跟另一个轨道的元素对齐的问题。
- ◆ 6.3 替代语法
- >> 当你构建一个网格时，选择一种舒适的语法即可。网格布局共设计了三种语法：编号的网格线、命名的网格线、命名的网格区域。
- ◆ 6.4 显式和隐式网格
- >> 使用grid-template-＊属性定义网格轨道时，创建的是显式网格（explicit grid），但是有些网格元素仍然可以放在显式轨道外面，此时会自动创建隐式轨道以扩展网格，从而包含这些元素。
- >> 有时候我们不想给一个网格轨道设置固定尺寸，但是又希望限制它的最小值和最大值。这时候需要用到minmax()函数。它指定两个值：最小尺寸和最大尺寸。浏览器会确保网格轨道的大小介于这两者之间。（如果最大尺寸小于最小尺寸，最大尺寸就会被忽略。）通过指定minmax(200px, 1fr)，浏览器确保了所有的轨道至少宽200px。
- >> repeat()函数里的auto-fill关键字是一个特殊值。设置了之后，只要网格放得下，浏览器就会尽可能多地生成轨道，并且不会跟指定大小（minmax()值）的限制产生冲突。
- >> auto-fill和minmax(200px, 1fr)加在一起，就会让网格在可用的空间内尽可能多地产生网格列，并且每个列的宽度不会小于200px
- >> 还可以额外加一个关键字dense（比如，grid-auto-flow: column dense）。它让算法紧凑地填满网格里的空白，尽管这会改变某些网格元素的顺序。加上这个关键字，小元素就会“回填”大元素造成的空白区域。
- >> 网格有一个限制是要求用特定的DOM结构，也就是说，所有的网格元素必须是网格容器的直接子节点。因此，不能将深层嵌套的元素在网格上对齐
- >> 可以给网格元素加上display: grid，在外层网格里创建一个内部网格，但是内部网格的元素不一定会跟外层网格的轨道对齐。一个网格里的子元素的大小也不能影响到另一个网格的网格轨道大小。
- >> 将来可以使用子网格（subgrid）来解决这个问题。通过给一个网格元素设置display:subgrid，将其变成自己的内部网格容器，网格轨道跟外部网格的轨道对齐。不幸的是，这个特性还没有被任何浏览器实现，因此它被推迟到网格规范的Level2版本中。
- >> ❑ cover：扩展图片，让它填满盒子（导致图片一部分被裁剪）。❑ contain：缩放图片，让它完整地填充盒子（导致盒子里出现空白）。
- ◆ 6.6 对齐
- >> 还有三个对齐属性：align-content、align-items、align-self。这些属性控制网格元素在垂直方向上的位置。我是这样记的：就像表格布局里的vertical-align属性。
- ◆ 6.7 总结
- >> 网格特别适合做网页整体布局
- >> 网格可以与Flexbox配合实现完整的布局系统。
- >> 可以根据自己的喜好和特定场景，随意使用不同的语法（编号的网格线、命名的网格线、命名的网格区域）。
- >> 可以用auto-fill / auto-fit以及隐式网格，对大量或者数量未知的网格元素进行布局。
- ◆ 7.1 固定定位
- >> 因为固定元素从文档流中移除了，所以它不再影响页面其他元素的位置。别的元素会跟随正常文档流，就像固定元素不存在一样。也就是说它们通常会在固定元素下面排列，视觉上被遮挡。这对于模态框来说没问题，因为我们希望模态框出现在最前面的中间位置，直到用户关闭它。而对于其他固定元素，比如侧边导航栏，就需要注意不要让其他内容出现在它下面。通常给其他内容加一个外边距就能解决该问题。比如，将所有内容放在容器里，容器设置right-margin:20%。外边距会流到固定元素下面，内容就不会跟导航栏重叠。
- ◆ 7.2 绝对定位
- >> 你可能首先想到将按钮里的文字close换成x，但是这会导致可访问性的问题：辅助的屏幕阅读器会读按钮里的文字。因此要给这个按钮一些有意义的提示。在使用CSS之前，HTML本身必须有意义。相反，你可以用CSS隐藏close，并显示x。总共需要两步。首先将按钮的文字挤到外面，并隐藏溢出内容。然后将按钮的：:after伪元素的content属性设置为x，并让伪元素绝对定位到按钮中间
- ◆ 7.3 相对定位
- >> 元素四周的边都变成了三角形。顶部的边箭头指向下边，右边的边指向左边，以此类推。基于这个现象，可以用一条边作为三角形，然后将剩下的边设置为透明。
- >> 另外你也可以用一个图片或者背景图来实现箭头，但是用短短几行CSS代码就可以为用户免去不必要的网络请求。加上这个小小的箭头，能给网站或应用程序增色不少。这项技术还可以用来构建其他复杂形状，比如梯形、六边形和星形。查看用CSS构建的各种形状，可以访问css-tricks网站上的文章The Shapes of CSS。
- ◆ 7.4 层叠上下文和z-index
- >> 通常情况下，模态框要放在网页内容的最后，</body>关闭标签之前。大多数构建模态框的JavaScript库会自动这样做。因为模态框使用固定定位，所以不必关心它的标记出现在哪里，它会一直定位到屏幕中间。
- >> 改变固定定位元素的标记位置不会产生不好的影响，但是对相对定位或绝对定位的元素来说，通常无法用改变标记位置的方法解决层叠问题。相对定位依赖于文档流，绝对定位元素依赖于它的定位祖先节点。这时候需要用z-index属性来控制它们的层叠行为。
- >> z-index的行为很好理解，但是使用它时要注意两个小陷阱。第一，z-index只在定位元素上生效，不能用它控制静态元素。第二，给一个定位元素加上z-index可以创建层叠上下文。
- >> 层叠上下文负责决定哪些元素出现在另一些元素前面，而BFC负责处理文档流，以及元素是否会重叠。
- >> 给一个定位元素加上z-index是创建层叠上下文最主要的方式，但还有别的属性也能创建，比如小于1的opacity属性，还有transform、filter属性。由于这些属性主要会影响元素及其子元素渲染的方式，因此一起绘制父子元素。文档根节点（<html>）也会给整个页面创建一个顶级的层叠上下文。
- >> 所有层叠上下文内的元素会按照以下顺序，从后到前叠放：
- >> 有些开发人员会忍不住给页面的大量元素使用定位。一定要克制这种冲动。定位用得越多，网页就越复杂，也就越难调试。如果你定位了大量元素，就回头评估一下现在的情况，尤其是当你发现很难调试出自己想要的布局时，一定要反思。如果可以用别的方法实现某个布局，应该优先用那些方法。
- >> 如果能够依靠文档流，而不是靠明确指定定位的方式实现布局，那么浏览器会帮我们处理好很多边缘情况。记住，定位会将元素拉出文档流。一般来说，只有在需要将元素叠放到别的元素之前时，才应该用定位。
- ◆ 7.6 总结
- >> ❑ 模态框使用固定定位。❑ 下拉菜单、工具提示及其他动态交互使用绝对定位。❑ 实现这些功能时还要考虑可访问性。❑ 关于z-index有两个地方要注意：它只对定位元素有效；它会创建一个层叠上下文。❑ 在一个页面创建多个层叠上下文时一定要当心潜在的陷阱。❑ 使用粘性定位时注意浏览器的兼容性。
- ◆ 第8章 响应式设计
- >> 响应式设计的三大原则如下。(1) 移动优先。这意味着在实现桌面布局之前先构建移动版的布局。(2) @media规则。使用这个样式规则，可以为不同大小的视口定制样式。用这一语法，通常叫作媒体查询（media queries），写的样式只在特定条件下才会生效。(3) 流式布局。这种方式允许容器根据视口宽度缩放尺寸。
- ◆ 8.1 移动优先
- >> 响应式设计的第一原则就是移动优先（mobile first），顾名思义就是构建桌面版之前要先构建移动端布局。这样才能确保两个版本都生效。开发移动版网页有很多限制：屏幕空间受限、网络更慢。用户跟网页交互的方式也不一样：可以打字，但是用着很别扭，不能将鼠标移动到元素上触发效果等。如果一开始就设计一个包含全部交互的网站，然后再根据移动设备的限制来制约网站的功能，那么一般会以失败告终。而移动优先的方式则会让你设计网站的时候就一直想着这些限制。一旦移动版的体验做好了（或者设计好了），就可以用“渐进增强”（progressive enhancement）的方式为大屏用户增加体验。
- >> 做响应式设计时，一定要确保HTML包含了各种屏幕尺寸所需的全部内容。你可以对每个屏幕尺寸应用不同的CSS，但是它们必须共享同一份HTML。
- >> 断点——一个特殊的临界值。屏幕尺寸达到这个值时，网页的样式会发生改变，以便给当前屏幕尺寸提供最佳的布局。
- >> 当点击汉堡包图标的时候，会打开下拉菜单，可以看到菜单的文字出现在网页内容前面。再次点击汉堡包图标就会关闭菜单。这种方式下，CSS会负责显示和隐藏指定元素，JavaScript只需要负责改变一个类。
- ◆ 8.2 媒体查询
- >> 大多数情况下，整个样式表里的媒体查询只会复用少数几个断点。
- >> 还可以进一步将两个条件用and关键字联合起来组成一个媒体查询，如下代码所示。[插图]这种联合媒体查询只在设备同时满足这两个条件时才生效。如果设备只需要满足多个条件之一，可以用逗号分隔，如下代码所示。[插图]这句媒体查询匹配小于等于20em的视口，以及大于等于35em的视口。
- >> 当你想在高分辨率的屏幕上提供更高清的图片或者图标时，可以用这种方法。这样低分辨率的屏幕就不会浪费带宽去加载大图，因为在这些屏幕上看不出区别。本章稍后会详细介绍响应式图片。
- >> 当你想在高分辨率的屏幕上提供更高清的图片或者图标时，可以用这种方法。这样低分辨率的屏幕就不会浪费带宽去加载大图，因为在这些屏幕上看不出区别。本章稍后会详细介绍响应式图片。
- >> 使用print媒体查询可以控制打印时的网页布局，这样就能在打印时去掉背景图（节省墨水），隐藏不必要的导航栏。当用户打印网页时，他们通常只想打印主体内容。
- >> 最优先的是移动端样式，因为它们不在媒体查询里，所以这些样式对所有断点都有效。然后是针对中等屏幕的媒体查询，其中的规则基于移动端样式构建并且会覆盖移动端样式。最后是针对大屏幕的媒体查询，在这里添加网页最后的布局。
- >> 有的设计可能只需要一个断点，有的设计可能需要多个断点。对网页上有很多元素来讲，无须给每个断点都添加样式，因为在小屏幕或者中等屏幕的断点下添加的样式规则在大屏幕的断点下也完全有效。
- >> 有时候移动端的样式可能很复杂，在较大的断点里面需要花费较大篇幅去覆盖样式。此时需要将这些样式放在max-width媒体查询中，这样就只对较小的断点生效，但是用太多的max-width媒体查询也很有可能是没有遵循移动优先原则所致。max-width是用来排除某些规则的方式，而不是一个常规手段。
- >> 接下来给中等屏幕断点添加样式。在较大的屏幕上，可用空间较多，布局可以较宽松一些。在代码清单8-9中，给头部和主元素添加更大的内边距，然后单独给主图加大内边距，使它更加明显，同时给页面增加了更多的视觉趣味。导航菜单不必隐藏了，要隐藏汉堡包图标，并让菜单项一直显示（参见代码清单8-10）。最终可以将主内容变成三列布局（参见代码清单8-11），页面将如图8-8所示。
- >> 最后一步是要为中等屏幕断点引入多列布局。和前面几章构建多列布局的方式一样，只需要将这些样式封装在一个媒体查询里，这样就不会影响到小于这个断点的屏幕设备。写标记的时候，给想要加上三列布局的地方加上row和column类。
- >> 你可能会好奇为什么在代码清单8-7中要将断点设置为35em，因为在这个宽度时，三列布局就开始显得拥挤了。
- >> Web设计师Brad Frost列举了一系列响应模式，可以访问https://bradfrost.github.io/this-is-responsive/patterns.html查看。响应式设计中的列非常灵活多变，比如一宽一窄的列、等宽的列、两列、三列。最终，这些列的布局都会使用类似于本章的方式实现，可能会组合多个列或者更改列宽。
- >> 有时候，甚至不需要媒体查询，自然地折行就能实现响应式的列。可以通过在Flexbox布局中使用flex-wrap: wrap并设置合适的flex-basis来实现。还可以在网格布局中使用auto-fit或者auto-fill的网格列，在折行之前就可以决定一行放几个元素。用inline-block的元素也行，只不过它们无法扩展到填满容器。
- >> 有时候会忍不住想要根据设备选择断点。这个iPhone 7宽多少像素，那个平板设备宽多少像素，等等。不要总想着设备。市面上有成百上千中设备和屏幕分辨率，无法逐一测试。相反，应该选择适合设计的断点，这样不管在什么设备上，都能有很好的表现。
- >> 媒体查询基于视口大小实现响应式设计，但是开发人员和浏览器厂商已经花了好几年时间来寻找更好的解决办法。很多开发人员希望得到的特性是容器查询（container queries），起初叫作元素查询（element queries）。这种查询不是响应视口，而是响应一个元素的容器的大小
- ◆ 8.3 流式布局
- >> 要习惯将容器宽度设置为百分比，而不是任何固定的值。
- >> 如果可以的话，建议在移动设备上用别的方式组织数据。比如将每一行数据单独用一块区域展示，让每块区域顺序叠放，或者用更适合小屏的可视化图形或者图表展示。
- ◆ 8.4 响应式图片
- >> 响应式图片的最佳实践是为一个图片创建不同分辨率的副本。如果用媒体查询能够知道屏幕的大小，就不必发送过大的图片，不然浏览器为了适配图片也会将其缩小。
- >> 在不同屏幕的浏览器上加载这样的网页，根本看不出有什么区别。这就是关键所在。在小断点下，屏幕尺寸不够宽，反正显示不了完整分辨率的图，但是能节省几百KB的流量。在图片较多的网页上，累计节省的流量就能够显著提升网页加载速度
- >> 这个属性是HTML的一个较新的特性。它可以为一个<img>标签指定不同的图片URL，并指定相应的分辨率。浏览器会根据自身需要决定加载哪一个图片
- >> 图片作为流式布局的一部分，请始终确保它不会超过容器的宽度。为了避免这种情况发生，一劳永逸的办法是在样式表加入规则img {max-width: 100%;
- >> 网页响应式设计的结构实现方式千变万化。最终这些方式都会归纳为三大原则：移动优先、媒体查询、流式布局。
- ◆ 8.5 总结
- >>❑ 优先实现移动端设计。
  ❑ 使用媒体查询，按照视口从小到大的顺序渐进增强网页。
  ❑ 使用流式布局适应任意浏览器尺寸。
  ❑ 使用响应式图片适应移动设备的带宽限制。
  ❑ 不要忘记给视口添加meta标签。
-